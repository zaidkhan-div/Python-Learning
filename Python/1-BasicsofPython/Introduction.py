import dis
# 1.Introduction to Python Bytecode

# Python bytecode is the intermediate representation of Python code that is generated by the Python compiler. When you write Python code, it is first compiled into bytecode, which is then executed by the Python interpreter.

# How Python Code is Compiled
# Here's a simplified overview of how Python code is compiled:

# Lexical Analysis: The Python code is broken down into individual tokens, such as keywords, identifiers, and literals.
# Syntax Analysis: The tokens are analyzed to ensure that the code follows the correct syntax.
# Semantic Analysis: The code is analyzed to ensure that it makes sense in terms of its meaning and context.
# Bytecode Generation: The compiled code is generated in the form of bytecode.

# Example of Python Bytecode

class Person: # Class Person (source code/blue print of an object at runtime)
    def __init__(self, name: str, age: int): # initilizer or constructor which is responsible to create Object in memory at runtime
        self.name = name           # Pereson attibute
        self.age = age             # Pereson attibute

    def greet(self): # Person Class method greet()
        print(f"Hello, my name is {self.name} and I am {self.age} years old.") # Print/Output to console/terminal

# Lets create a Person object in memory
person: Person = Person("Arif Rozani", 20)
newPerson:Person = Person('Zaidkhan',18)
# print(newPerson.name)

person.greet() # Lets call Person Object's greet method
# dis.dis(Person)
# The dis module in Python is a built-in module that provides a way to disassemble and inspect the bytecode of Python objects, such as functions, methods, and classes.

# How Python Uses Bytecode:
# Compilation: When you run a Python script, the Python interpreter first compiles it into bytecode.
# Execution: The compiled bytecode is executed by the Python Virtual Machine (PVM).
# Caching: Python caches the compiled bytecode in the pycache directory to speed up subsequent executions.
# Python bytecode is platform-independent, Meaning the (.pyc files) can run on any Os as long as the Python interpreter version matches. 

# Run command python -m compileall TestP.py
# It create the byte code in __pycache__ folder

# <===============> X <=================> X <===================> X
# 2.Indentation in Python.# X <====================> <================> <==================> X 


# In Python, indentation is used to denote a block of code within a control structure, function, or class. It is a crucial aspect of Python syntax, and incorrect indentation can lead to syntax errors.

# What is Indentation?
# Indentation is the process of adding spaces or tabs to the beginning of a line of code to indicate that it is part of a larger block of code. In Python, indentation is used to define the structure of the code and to show the relationship between different blocks of code.

# Indentation is important because it helps to:
# Define the structure of the code
# Show the relationship between different blocks of code
# Make the code more readable and understandable
# Prevent syntax errors

# Correct indentation
if True:
    print("Hello, World!")
    print("This is a block of code")

# Incorrect indentation
if True:
# print("Hello, World!")
  print("This is a block of code")

# Correct indentation
def greet(name: str):
    print("Hello, " + name + "!")

# Incorrect indentation
# def greet(name: str):
# print("Hello, " + name + "!")

def hello(
        first:bool,second:bool
):
    if first and second:
        raise ValueError('no')
    elif first:
        print('First')
    elif second:
        print('second')
    return 'done'
hello('False',False)

# <===============> X <=================> X <===================> X
# 3.Python is a Dynamically-Typed Language with Optional Type Hinting
# Python is a dynamically-typed language, which means that it does not enforce the data type of a variable at compile time. Instead, the data type is determined at runtime.
# However, Python 3.5 and later versions also support optional type hinting, which allows developers to add type annotations to their code to specify the expected types of variables, function parameters, and return types.

age: int = input("Enter your age: ")
print(f"Your age is {age}")

print("type(age) = ", type(age))

# Basic Syntax
# The basic syntax for type hinting is to add a colon (:) followed by the expected type after the variable or function parameter. For example:
x: int = 5
y: str = "hello"

# Function Type Hints
# You can also add type hints to function parameters and return types using the following syntax:
def greet(name: str) -> str:
    return "Hello, " + name + "!"
# In this example, the greet function takes a name parameter of type str and returns a value of type str.

# Type Hinting for Complex Types
# You can also use type hinting for more complex types, such as lists, dictionaries, and tuples. For example:

my_list: list[int] = [1, 2, 3]
my_dict: dict[str, int] = {"a": 1, "b": 2}
my_tuple: tuple[str, int] = ("hello", 5)